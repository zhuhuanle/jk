

## 并发

多线程操作出现抢夺资源或者可能会出现抢夺资源的情况就需要考虑并发问题。

### 操作基础是多线程

```java
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(        2, 5, 1, TimeUnit.MINUTES,        new LinkedBlockingDeque<>(6), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());
```

### 常用的安全容器

#### Vector

```java
Vector vector = new Vector();
```

#### Hashtable

```java
Hashtable<String, String> hashMap = new Hashtable<>();
// 给每个方法上加锁 锁的是table对象
```

#### ConcurrentHashMap

```java
ConcurrentHashMap<String, String> concurrentHashMap = new ConcurrentHashMap<>();
// jdk7 采用分段锁
// jdk8 采用锁的是单个节点
```

#### CopyOnWriteArrayList

```java
CopyOnWriteArrayList<String> copyOnWriteArrayList = new CopyOnWriteArrayList<>();CopyOnWriteArraySet<String> copyOnWriteArraySet = new CopyOnWriteArraySet<>();
// 支持并发读 写会加锁 写操作就是复制原来的对象，创建新的对象size+1 并且把新的元素写入 完成操作后将引用指针指向新的对象
```

#### Collections.synchronized

```java
// 通过集合工具包将集合对象转化为安全容器
List<String> list = Collections.synchronizedList(new ArrayList<>());Set<String> set = Collections.synchronizedSet(new HashSet<>(8));Map<String, Object> map = Collections.synchronizedMap(new HashMap<>(8));
```

### 并发关键字synchronized

sync关键字可以加在方法 普通方法锁的是当前对象，加在静态方法上锁的是类，

sync可以单独加载代码片段上锁的是代码片段

### 锁对象ReentrantLock

```java
ReentrantLock reentrantLock = new ReentrantLock();reentrantLock.lock();try {    List<String> list = Collections.synchronizedList(new ArrayList<>());}catch (Exception e){}finally {    reentrantLock.unlock();}
```

### 并发工具

#### Condition

Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition()
调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用
Conditon中的await()对应Object的wait()；

Condition中的signal()对应Object的notify()；

Condition中的signalAll()对应Object的notifyAll()。

#### CountDownLatch 门闩

```java
// 等待所有都吃完了再收桌子
CountDownLatch countDownLatch = new CountDownLatch(3);
```

#### Semaphore 信号量

```java
// 厕所坑位 走一个进一个
Semaphore semaphore = new Semaphore(3);
```

#### CyclicBarrier  循环栅栏 

```
public class Test implements Runnable {        private int code;    private CyclicBarrier cyclicBarrier;    public Test(int code, CyclicBarrier cyclicBarrier) {        this.code = code;        this.cyclicBarrier = cyclicBarrier;    }    @Override    public void run() {        System.out.println("编号:" + code + "的学员已经就位");        try {            cyclicBarrier.await();//阻塞,直到去除屏障            System.out.println("编号:" + code + "的学员已经出发");        } catch (Exception e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new Thread(() -> {            System.out.println("人员到齐,出发");        }));        new Thread(new Test(1, cyclicBarrier)).start();        new Thread(new Test(2, cyclicBarrier)).start();        new Thread(new Test(3, cyclicBarrier)).start();    }
```

